# ЭФМО-01-25 Буров М.А. ПР13

# Описание проекта
Профилирование Go-приложения (pprof). Измерение времени работы функций

# Требования к проекту
* Go 1.25+
* Git

# Версия Go
<img width="317" height="55" alt="image" src="https://github.com/user-attachments/assets/43f9087b-95b9-4c7d-86e9-746258c45c63" />

# Цели:
1.	Научиться подключать и использовать профилировщик pprof для анализа CPU, памяти, блокировок и горутин.
2.	Освоить базовые техники измерения времени выполнения функций (ручные таймеры, бенчмарки).
3.	Научиться читать отчёты go tool pprof, строить графы вызовов и находить “узкие места”.
4.	Сформировать практические навыки оптимизации кода на основании метрик.

# Краткое описание
Профилирование показывает, где тратятся CPU-циклы, память, где происходят блокировки, сколько активных горутин и т.п. Решает две задачи: (а) находить узкие места; (б) проверять, что оптимизация действительно помогает.

# Структура проекта
Дерево структуры проекта: 
```
pz11-notes-api/
├── cmd/
│   └── api/
│       └── main.go
├── internal/
│   ├── core/
│   │   ├── note.go
│   │   └── service/
│   │       └── note_service.go
│   ├── http/
│   │   ├── router.go
│   │   └── handlers/
│   │       └── notes.go
│   └── repo/
│       └── note_mem.go
├── docs/
│   ├── docs.go
│   ├── swagger.json
│   └── swagger.yaml
├── go.mod
└── go.sum
```

# Скриншоты


# Краткие выводы


# Ответы на контрольные вопросы

1.	Чем профилирование отличается от логирования и простых таймеров?
2.	Что показывает CPU-профиль и как его интерпретировать (top, list, graph)?
3.	В чём разница allocs и inuse в Heap-профиле?
4.	Как включить и для чего анализировать block и mutex профили?
5.	Какие метрики дают бенчмарки testing.B, что означает ns/op, B/op, allocs/op?
6.	Почему важно сравнивать оптимизации на одинаковой нагрузке и фиксировать «до/после»?
7.	Какой порядок действий при поиске узкого места в производительности?
